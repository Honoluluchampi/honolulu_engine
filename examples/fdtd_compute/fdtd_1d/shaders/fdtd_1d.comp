#version 450

#extension GL_GOOGLE_include_directive : require

#include "../common.h"

layout (local_size_x = fdtd1_local_size_x, local_size_y = fdtd1_local_size_y, local_size_z = fdtd1_local_size_z) in;

// field
layout (std430, set = 0, binding = 0) buffer Curr { particle curr[]; };
layout (std430, set = 1, binding = 0) buffer Prev { particle prev[]; };
layout (std430, set = 2, binding = 0) buffer Sound { float sound_buffer[]; };
layout (push_constant) uniform Push { fdtd_push push; };

#define M_PI 3.14159265359

float calc_v(uint id)
{
  float p0 = prev[id - 1].p;
  float p1 = prev[id + 0].p;
  float p_inter = (p0 + p1) / 2.f;
  float p_term = p1 - p0;

  float s0 = M_PI * pow(prev[id - 1].y_offset, 2.f);
  float s1 = M_PI * pow(prev[id + 0].y_offset, 2.f);
  float s_inter = (s0 + s1) / 2.f;
  float s_term = p_inter / s_inter * (s1 - s0);

  return (prev[id].v - push.v_fac * (p_term + s_term)) / (1.f + prev[id].pml);
}

float calc_p(uint id, float v1)
{
  float v0 = curr[id + 0].v;
  float v_inter = (v0 + v1) / 2.f;
  float v_term = v1 - v0;

  float s0 = M_PI * pow(curr[id - 1].y_offset, 2.f);
  float s1 = M_PI * pow(curr[id + 0].y_offset, 2.f);
  float s2 = M_PI * pow(curr[id + 1].y_offset, 2.f);
  float s_inter0 = (s0 + s1) / 2.f;
  float s_inter1 = (s1 + s2) / 2.f;
  float s_term = v_inter / s1 * (s_inter1 - s_inter0);

  return (prev[id].p - push.p_fac * (v_term + s_term)) / (1.f + prev[id].pml);
}

// exciter constants
const float w = 0.012;
const float h = 0.0006;
const float k = 8000000;
const float rho = 1.1;
const float dp_max = k * h;
const float c_area = w * h;

void main()
{
  uint id = gl_LocalInvocationID.x + gl_WorkGroupID.x * fdtd1_local_size_x;

  // update velocity
  if (1 <= id && id < push.whole_grid_count) {
    curr[id].v = calc_v(id);
  }

  // update pressure
  if (id < push.whole_grid_count) {
    // compute the next velocity not to add memory barrier
    float curr_v1 = calc_v(id + 1);
    curr[id].p = calc_p(id, curr_v1);

    if (id >= push.main_grid_count) {
      curr[id].p = 0.f;
    }
  }

  // exciter
  if (id == 0) {
    curr[id].v = sin(push.phase);
//    float dp = 4000.f - prev[id].p;
//    float u_bore = c_area * (1 - dp / dp_max) * sqrt(2.f * dp / rho);
//    if (dp <= 0.05 * dp_max)
//      u_bore = 0.f;
//    float shelf = 0.5 + 0.5 * tanh(4.f * (-1.f + (dp_max - dp) / (0.01 * dp_max)));
//    curr[id].v = u_bore * shelf / 0.000367;
  }

  // record sound buffer
  if (id == 0) {//push.main_grid_count - 1) {
    //sound_buffer[push.sound_buffer_id] = curr[id].p;
    sound_buffer[push.sound_buffer_id] = curr[id].v;
  }
}