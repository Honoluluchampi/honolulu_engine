#version 450

#extension GL_GOOGLE_include_directive : require

#include "../../common/cloth_config.h"

layout (local_size_x = fdtd2_local_size_x, local_size_y = fdtd2_local_size_y, local_size_z = 1) in;

// pressure
layout(set = 0, binding = 0) buffer CurrentP { float curr_p[]; };
layout(set = 0, binding = 1) buffer CurrentVx { float curr_vx[]; };
layout(set = 0, binding = 2) buffer CurrentVy { float curr_vy[]; };

layout(set = 1, binding = 0) readonly buffer PreviousP { float prev_p[]; };
layout(set = 1, binding = 1) readonly buffer PreviousVx { float prev_vx[]; };
layout(set = 1, binding = 2) readonly buffer PreviousVy { float prev_vy[]; };
// push constants
layout(push_constant) uniform Push { fdtd2_push push; };

uint p_id(uint x, uint y) { return x + y * push.x_grid; }
uint vx_id(uint x, uint y) { return (x + 1) + y * (push.x_grid + 1); }
uint vy_id(uint x, uint y) { return x + (y + 1) * push.x_grid; }

void main() {
  uint i = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
  uint j = gl_WorkGroupID.y * gl_WorkGroupSize.y + gl_LocalInvocationID.y;

  // update particle velocity
  // neumann bc
  if (i < push.x_grid - 1) {
    curr_vx[vx_id(i, j)] = prev_vx[vx_id(i, j)] - push.v_fac *
                                 (prev_p[p_id(i + 1, j)] - prev_p[p_id(i, j)]); }
  if (j < push.y_grid - 1) {
    curr_vy[vy_id(i, j)] = prev_vy[vy_id(i, j)] - push.v_fac *
                                 (prev_p[p_id(i, j + 1)] - prev_p[p_id(i, j)]); }

  // update pressure
  curr_p[p_id(i, j)] = prev_p[p_id(i, j)] - push.p_fac *
                             (curr_vx[vx_id(i, j)] - curr_vx[vx_id[i-1, j]] +
                              curr_vy[vy_id(i, j)] - curr_vy[vy_id[i, j-1]]);
}