#version 450

#extension GL_GOOGLE_include_directive : require

#include "../../common/fdtd2_config.h"
#include "../../common/fdtd_struct.h"

layout (local_size_x = fdtd2_local_size_x, local_size_y = fdtd2_local_size_y, local_size_z = 1) in;

// pressure
layout(std430, set = 0, binding = 0) buffer CurrentP { particle curr_p[]; };
layout(std430, set = 1, binding = 0) readonly buffer PreviousP { particle prev_p[]; };

// push constants
layout(push_constant) uniform Push { fdtd2_push push; };

// grid id
uint g_id(uint x, uint y) { return x + y * push.x_grid; }

void main() {
  uint i = gl_LocalInvocationID.x + gl_WorkGroupID.x * fdtd2_local_size_x;
  uint j = gl_LocalInvocationID.y + gl_WorkGroupID.y * fdtd2_local_size_y;

//  if (push.reset >= 1) {
//    curr_p[p_id(i, j)].value = 0.f;
//    curr_vx[vx_id(i, j)].value = 0.f;
//    curr_vy[vy_id(i, j)].value = 0.f;
//    if (i == push.x_grid / 2 && j == push.y_grid / 2)
//      curr_p[p_id(i, j)].value = 128.f;
//
//    if (i == push.x_grid / 4 && j == push.y_grid / 4)
//      curr_p[p_id(i, j)].value = -16.f;
//    return;
//  }

  // update particle velocity
  // neumann bc
  if (i < push.x_grid - 1) {
    curr_p[g_id(i, j)].values.x = prev_p[g_id(i, j)].values.x - push.v_fac *
                          (prev_p[g_id(i + 1, j)].values.z - prev_p[g_id(i, j)].values.z); }
  if (j < push.y_grid - 1) {
    curr_p[g_id(i, j)].values.y = prev_p[g_id(i, j)].values.y - push.v_fac *
                          (prev_p[g_id(i, j + 1)].values.z - prev_p[g_id(i, j)].values.z); }

  barrier();
//  if (i < push.x_grid && j < push.y_grid && i > 0 && j > 0) {
    // update pressure
    curr_p[g_id(i, j)].values.z = prev_p[g_id(i, j)].values.z - push.p_fac *
                        (curr_p[g_id(i, j)].values.x - curr_p[g_id(i - 1, j)].values.x +
                         curr_p[g_id(i, j)].values.y - curr_p[g_id(i, j - 1)].values.y);
//  }
}