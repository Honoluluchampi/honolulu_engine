#version 450

#extension GL_GOOGLE_include_directive : require

// include common struct (cloth_push)
#include "../../common/cloth_config.h"

layout (local_size_x = cloth_local_size_x, local_size_y = cloth_local_size_y, local_size_z = 1) in;

struct vertex {
 vec3 position;
 vec3 velocity;
};

// game::compute_shader binds current and previous vertices properly
layout(set = 0, binding = 0) buffer Vertex0 {
  vertex curr_v[];
};

layout(set = 1, binding = 0) readonly buffer Vertex1 {
  vertex prev_v[];
};

layout(push_constant) uniform Push {
  cloth_push push;
};

// returns true if the vertex is inside the cloth
bool exists_vertex(uint x_id, uint y_id) {
  return x_id < push.x_grid && y_id < push.y_grid;
}

vec3 get_prev_position(uint x_id, uint y_id) {
  return prev_v[x_id + y_id * push.x_grid].position;
}

vec3 get_prev_velocity(uint x_id, uint y_id) {
  return prev_v[x_id + y_id * push.x_grid].velocity;
}

struct id_pair {
  ivec2 pairs[4];
};

const ivec2 id_diff0[4] = { ivec2(0, 1), ivec2(0, -1), ivec2(1, 0), ivec2(-1, 0) };
const ivec2 id_diff1[4] = { ivec2(1, 1), ivec2(1, -1), ivec2(-1, 1), ivec2(-1, -1) }; // shear
const ivec2 id_diff2[4] = { ivec2(0, 2), ivec2(0, -2), ivec2(2, 0), ivec2(-2, 0) }; // flexion

const id_pair id_diff[3] = {
  id_pair(id_diff0),
  id_pair(id_diff1),
  id_pair(id_diff2)
};

const float mass = 1;
const float gravity = 0.98;

const float stiffs[3] = {
  10000, // structural
  3000, // shear
  10000  // flexion
};

const float spring_dumping = 5.0;

const float rest_coef[3] = {
  1.0,
  sqrt(2.0),
  2.0
};

vec3 gravity_force() {
  return vec3(0, mass * gravity, 0);
}

vec3 spring_force(int spring_type, uint x_id, uint y_id) {
  vec3 ret = vec3(0, 0, 0);

  // this position will be updated
  vec3 target = get_prev_position(x_id, y_id);

  // TODO : LOOP UNROLL
  for (int i = 0; i < 4; i++) {
    // length of rest state
    float rest = rest_coef[spring_type] * push.x_len / (float(push.x_grid) - 1.0);

    // calc difference of positions
    ivec2 elem_id = id_diff[spring_type].pairs[i];
    vec3 elem = target - get_prev_position(x_id + elem_id.x, y_id + elem_id.y);

    // if elem vertex does not exist, ret would not be updated
    ret += float(exists_vertex(x_id + elem_id.x, y_id + elem_id.y)) // check existance without 'if'
        * stiffs[spring_type] * (rest - length(elem)) * normalize(elem);
  }

  return ret;
}

vec3 spring_dumping_force(uint x_id, uint y_id) {
  return -spring_dumping * get_prev_velocity(x_id, y_id);
}

vec3 gather_spring_force(uint x_id, uint y_id) {
  vec3 ret = vec3(0, 0, 0);
  ret += spring_force(0, x_id, y_id) / mass;
  ret += spring_force(1, x_id, y_id) / mass;
  ret += spring_force(2, x_id, y_id) / mass;
  // spring dumping
  ret += spring_dumping_force(x_id, y_id) / mass;

  return ret;
}

void main()
{
  uint x_id = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
  uint y_id = gl_WorkGroupID.y * gl_WorkGroupSize.y + gl_LocalInvocationID.y;
  uint index = x_id + y_id * push.x_grid;

  // update velocity
  vec3 whole_force = gather_spring_force(x_id, y_id) + gravity_force();

  // fix corner
  if (index != 0) {
    curr_v[index].velocity = prev_v[index].velocity + push.dt * whole_force;
    // update position
    curr_v[index].position = prev_v[index].position + push.dt * curr_v[index].velocity;
  }
}